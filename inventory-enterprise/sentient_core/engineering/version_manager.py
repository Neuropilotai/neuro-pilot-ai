#!/usr/bin/env python3
"""
NeuroPilot v17.5 - Version Manager

Orchestrates autonomous version evolution, upgrade planning, and deployment.

Author: NeuroPilot Engineering Team
Version: 17.5.0
"""

import json
import logging
import subprocess
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


@dataclass
class VersionPlan:
    """Upgrade plan generated by Architect Agent"""
    current_version: str
    target_version: str
    changes: List[Dict]
    estimated_duration_minutes: int
    risk_level: str  # low, medium, high
    rollback_plan: str
    timestamp: str


@dataclass
class UpgradeResult:
    """Result of version upgrade execution"""
    success: bool
    version: str
    changes_applied: int
    tests_passed: bool
    compliance_score: int
    duration_seconds: float
    rollback_executed: bool
    details: Dict
    timestamp: str


class VersionManager:
    """
    Manages autonomous version evolution and upgrades.

    Coordinates:
    - Architect Agent (planning)
    - Refactor Agent (code improvements)
    - Validator Agent (testing)
    - Compliance Agent (validation)
    """

    def __init__(self, config_path: str = "sentient_core/config/sentient_config.yaml"):
        self.config_path = config_path
        self.repo_path = Path("/Users/davidmikulis/neuro-pilot-ai/inventory-enterprise")
        self.engineering_dir = Path("sentient_core/engineering")
        self.plans_dir = self.engineering_dir / "plans"
        self.plans_dir.mkdir(parents=True, exist_ok=True)

        # Load current version
        self.current_version = self._get_current_version()

        # Agents (will be initialized on demand)
        self.architect = None
        self.refactor = None
        self.validator = None
        self.compliance = None

        logger.info(f"üîß Version Manager initialized (current: {self.current_version})")

    def _get_current_version(self) -> str:
        """Get current NeuroPilot version"""
        try:
            # Try reading from __init__.py
            init_file = self.repo_path / "sentient_core" / "__init__.py"
            if init_file.exists():
                with open(init_file, 'r') as f:
                    for line in f:
                        if '__version__' in line:
                            version = line.split('=')[1].strip().strip('"\'')
                            return version
        except Exception as e:
            logger.warning(f"Could not read version: {e}")

        return "17.5.0"  # Default

    def plan_upgrade(
        self,
        telemetry: Dict,
        target_improvements: Optional[List[str]] = None
    ) -> VersionPlan:
        """
        Plan next version upgrade based on telemetry and desired improvements.

        Args:
            telemetry: System metrics, logs, and performance data
            target_improvements: Specific areas to improve (e.g., ["forecast_accuracy", "cost_optimization"])

        Returns:
            VersionPlan with proposed changes
        """
        logger.info("üèóÔ∏è  Planning version upgrade...")

        # Initialize Architect Agent if needed
        if self.architect is None:
            from .architect_agent import ArchitectAgent
            self.architect = ArchitectAgent()

        # Analyze current state
        analysis = self._analyze_current_state(telemetry)

        # Generate upgrade plan
        plan = self.architect.design_upgrade(
            current_version=self.current_version,
            analysis=analysis,
            target_improvements=target_improvements
        )

        # Save plan
        plan_file = self.plans_dir / f"upgrade_plan_{plan.target_version}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.json"
        with open(plan_file, 'w') as f:
            json.dump({
                'current_version': plan.current_version,
                'target_version': plan.target_version,
                'changes': plan.changes,
                'estimated_duration_minutes': plan.estimated_duration_minutes,
                'risk_level': plan.risk_level,
                'rollback_plan': plan.rollback_plan,
                'timestamp': plan.timestamp
            }, f, indent=2)

        logger.info(f"‚úì Upgrade plan generated: {self.current_version} ‚Üí {plan.target_version}")
        logger.info(f"  Changes: {len(plan.changes)}")
        logger.info(f"  Risk: {plan.risk_level}")
        logger.info(f"  Duration: ~{plan.estimated_duration_minutes} minutes")

        return plan

    def execute_upgrade(
        self,
        plan: VersionPlan,
        dry_run: bool = True
    ) -> UpgradeResult:
        """
        Execute version upgrade according to plan.

        Args:
            plan: VersionPlan to execute
            dry_run: If True, validate but don't apply changes

        Returns:
            UpgradeResult with execution details
        """
        start_time = datetime.utcnow()

        logger.info("=" * 70)
        logger.info(f"üöÄ EXECUTING UPGRADE: {plan.current_version} ‚Üí {plan.target_version}")
        if dry_run:
            logger.info("   MODE: DRY-RUN (validation only)")
        logger.info("=" * 70)

        result = UpgradeResult(
            success=False,
            version=plan.target_version,
            changes_applied=0,
            tests_passed=False,
            compliance_score=0,
            duration_seconds=0,
            rollback_executed=False,
            details={},
            timestamp=datetime.utcnow().isoformat()
        )

        try:
            # Phase 1: Pre-upgrade validation
            logger.info("Phase 1: Pre-upgrade validation")
            if not self._validate_prerequisites(plan):
                logger.error("‚ùå Pre-upgrade validation failed")
                return result
            logger.info("‚úì Pre-upgrade validation passed")

            # Phase 2: Apply changes
            logger.info("Phase 2: Applying changes")
            changes_applied = 0

            for i, change in enumerate(plan.changes, 1):
                logger.info(f"  Change {i}/{len(plan.changes)}: {change['type']} - {change['description']}")

                if not dry_run:
                    success = self._apply_change(change)
                    if success:
                        changes_applied += 1
                    else:
                        logger.error(f"    ‚úó Failed to apply change: {change['description']}")
                        # Rollback
                        self._rollback_changes(plan)
                        result.rollback_executed = True
                        return result
                else:
                    logger.info("    (dry-run: skipped)")

            result.changes_applied = changes_applied if not dry_run else len(plan.changes)
            logger.info(f"‚úì Changes applied: {result.changes_applied}")

            # Phase 3: Run tests
            logger.info("Phase 3: Running validation tests")
            if self.validator is None:
                from .validator_agent import ValidatorAgent
                self.validator = ValidatorAgent()

            tests_passed = self.validator.run_validation_suite(
                version=plan.target_version,
                dry_run=dry_run
            )
            result.tests_passed = tests_passed
            logger.info(f"{'‚úì' if tests_passed else '‚úó'} Tests: {'PASSED' if tests_passed else 'FAILED'}")

            if not tests_passed and not dry_run:
                logger.error("‚ùå Tests failed, rolling back")
                self._rollback_changes(plan)
                result.rollback_executed = True
                return result

            # Phase 4: Compliance check
            logger.info("Phase 4: Compliance validation")
            if self.compliance is None:
                from .compliance_agent import ComplianceAgent
                self.compliance = ComplianceAgent()

            compliance_score = self.compliance.validate_upgrade(
                plan=plan,
                dry_run=dry_run
            )
            result.compliance_score = compliance_score
            logger.info(f"‚úì Compliance score: {compliance_score}/100")

            if compliance_score < 90 and not dry_run:
                logger.error("‚ùå Compliance score too low, rolling back")
                self._rollback_changes(plan)
                result.rollback_executed = True
                return result

            # Phase 5: Commit changes (if not dry-run)
            if not dry_run:
                logger.info("Phase 5: Committing changes")
                self._commit_version_upgrade(plan)
                logger.info("‚úì Changes committed to git")
            else:
                logger.info("Phase 5: (dry-run: no commit)")

            # Success!
            result.success = True
            result.duration_seconds = (datetime.utcnow() - start_time).total_seconds()

            logger.info("=" * 70)
            logger.info(f"‚úÖ UPGRADE {'VALIDATED' if dry_run else 'COMPLETED'}: {plan.target_version}")
            logger.info(f"   Duration: {result.duration_seconds:.1f}s")
            logger.info("=" * 70)

            return result

        except Exception as e:
            logger.error(f"‚ùå Upgrade failed: {e}")
            result.details['error'] = str(e)

            if not dry_run:
                logger.info("Rolling back...")
                self._rollback_changes(plan)
                result.rollback_executed = True

            result.duration_seconds = (datetime.utcnow() - start_time).total_seconds()
            return result

    def auto_evolve(
        self,
        telemetry: Dict,
        create_pr: bool = True
    ) -> Optional[str]:
        """
        Autonomous evolution cycle: analyze ‚Üí plan ‚Üí validate ‚Üí PR.

        Args:
            telemetry: System performance and metrics
            create_pr: If True, create GitHub PR for review

        Returns:
            PR URL if created, None otherwise
        """
        logger.info("üß† Starting autonomous evolution cycle...")

        # Step 1: Plan upgrade
        plan = self.plan_upgrade(telemetry)

        # Step 2: Validate upgrade (dry-run)
        result = self.execute_upgrade(plan, dry_run=True)

        if not result.success:
            logger.warning("‚ö†Ô∏è  Upgrade validation failed, skipping auto-evolution")
            return None

        # Step 3: If validated, execute upgrade
        logger.info("‚úì Validation passed, executing upgrade...")
        result = self.execute_upgrade(plan, dry_run=False)

        if not result.success:
            logger.error("‚ùå Upgrade execution failed")
            return None

        # Step 4: Create PR for review
        if create_pr:
            pr_url = self._create_pull_request(plan, result)
            logger.info(f"‚úì Pull request created: {pr_url}")
            return pr_url

        return None

    def _analyze_current_state(self, telemetry: Dict) -> Dict:
        """Analyze current system state from telemetry"""
        analysis = {
            'performance': {
                'uptime': telemetry.get('uptime_percentage', 99.99),
                'latency_p95': telemetry.get('p95_latency', 200),
                'error_rate': telemetry.get('error_rate', 0.5),
            },
            'cost': {
                'current_monthly': telemetry.get('monthly_cost', 30),
                'trend': telemetry.get('cost_trend', 'stable')
            },
            'forecasting': {
                'accuracy': telemetry.get('forecast_accuracy', 0.89),
                'false_positives': telemetry.get('false_positives', 0.04)
            },
            'remediation': {
                'success_rate': telemetry.get('remediation_success_rate', 0.97),
                'average_time': telemetry.get('avg_remediation_time', 120)
            },
            'compliance': {
                'score': telemetry.get('compliance_score', 91),
                'critical_findings': telemetry.get('critical_findings', 0)
            }
        }

        return analysis

    def _validate_prerequisites(self, plan: VersionPlan) -> bool:
        """Validate prerequisites for upgrade"""
        # Check git status
        try:
            result = subprocess.run(
                "git status --porcelain",
                shell=True,
                capture_output=True,
                text=True,
                cwd=self.repo_path
            )

            if result.stdout.strip():
                logger.warning("‚ö†Ô∏è  Uncommitted changes detected")
                # Could commit them automatically or require clean state
        except Exception as e:
            logger.error(f"Git status check failed: {e}")
            return False

        # Check Python dependencies
        # Check disk space
        # Check API connectivity

        return True

    def _apply_change(self, change: Dict) -> bool:
        """Apply a single change from upgrade plan"""
        change_type = change.get('type')

        if change_type == 'code_refactor':
            # Use Refactor Agent
            if self.refactor is None:
                from .refactor_agent import RefactorAgent
                self.refactor = RefactorAgent()

            return self.refactor.apply_refactor(change)

        elif change_type == 'config_update':
            # Update configuration file
            return self._update_config(change)

        elif change_type == 'dependency_update':
            # Update requirements.txt
            return self._update_dependencies(change)

        elif change_type == 'new_feature':
            # Add new functionality
            return self._add_feature(change)

        else:
            logger.warning(f"Unknown change type: {change_type}")
            return False

    def _update_config(self, change: Dict) -> bool:
        """Update configuration file"""
        try:
            config_file = change.get('file', 'sentient_core/config/sentient_config.yaml')
            updates = change.get('updates', {})

            # Load, update, save (simplified)
            logger.info(f"    Updating {config_file}: {len(updates)} changes")

            # In real implementation, would use YAML parser
            return True
        except Exception as e:
            logger.error(f"Config update failed: {e}")
            return False

    def _update_dependencies(self, change: Dict) -> bool:
        """Update Python dependencies"""
        try:
            package = change.get('package')
            version = change.get('version')

            logger.info(f"    Updating dependency: {package}=={version}")

            # In real implementation, would update requirements.txt
            return True
        except Exception as e:
            logger.error(f"Dependency update failed: {e}")
            return False

    def _add_feature(self, change: Dict) -> bool:
        """Add new feature/functionality"""
        try:
            feature_name = change.get('name')
            module = change.get('module')

            logger.info(f"    Adding feature: {feature_name} to {module}")

            # In real implementation, would generate code
            return True
        except Exception as e:
            logger.error(f"Feature addition failed: {e}")
            return False

    def _rollback_changes(self, plan: VersionPlan) -> bool:
        """Rollback all changes from upgrade"""
        logger.info("‚è™ Rolling back changes...")

        try:
            # Git reset
            subprocess.run(
                "git reset --hard HEAD",
                shell=True,
                cwd=self.repo_path
            )

            logger.info("‚úì Rollback complete")
            return True
        except Exception as e:
            logger.error(f"Rollback failed: {e}")
            return False

    def _commit_version_upgrade(self, plan: VersionPlan) -> None:
        """Commit version upgrade to git"""
        try:
            # Git add
            subprocess.run(
                "git add .",
                shell=True,
                cwd=self.repo_path
            )

            # Git commit
            commit_message = f"""chore(version): upgrade to {plan.target_version}

# [AUTO-ENGINEERED] by NeuroPilot v17.5 Engineering Mode

Changes:
{chr(10).join(f'- {c["description"]}' for c in plan.changes[:10])}

Risk Level: {plan.risk_level}
Duration: {plan.estimated_duration_minutes} minutes

ü§ñ Generated autonomously by NeuroPilot Engineering Agent
"""

            subprocess.run(
                f'git commit -m "{commit_message}"',
                shell=True,
                cwd=self.repo_path
            )

        except Exception as e:
            logger.error(f"Git commit failed: {e}")

    def _create_pull_request(self, plan: VersionPlan, result: UpgradeResult) -> str:
        """Create GitHub pull request for review"""
        try:
            # Create branch
            branch_name = f"auto-upgrade/{plan.target_version}"
            subprocess.run(
                f"git checkout -b {branch_name}",
                shell=True,
                cwd=self.repo_path
            )

            # Push branch
            subprocess.run(
                f"git push origin {branch_name}",
                shell=True,
                cwd=self.repo_path
            )

            # Create PR using GitHub CLI
            pr_title = f"[AUTO-ENGINEERED] Upgrade to {plan.target_version}"
            pr_body = f"""# NeuroPilot v{plan.target_version} - Autonomous Upgrade

**Generated by:** NeuroPilot v17.5 Engineering Mode
**Risk Level:** {plan.risk_level}
**Duration:** {result.duration_seconds:.1f}s

## Changes

{chr(10).join(f'- {c["description"]}' for c in plan.changes)}

## Validation Results

- **Tests Passed:** {'‚úÖ Yes' if result.tests_passed else '‚ùå No'}
- **Compliance Score:** {result.compliance_score}/100
- **Changes Applied:** {result.changes_applied}

## Rollback Plan

{plan.rollback_plan}

---

ü§ñ This PR was autonomously generated and validated.
Human review recommended before merge.
"""

            result = subprocess.run(
                f'gh pr create --title "{pr_title}" --body "{pr_body}"',
                shell=True,
                capture_output=True,
                text=True,
                cwd=self.repo_path
            )

            if result.returncode == 0:
                pr_url = result.stdout.strip()
                return pr_url
            else:
                logger.error(f"PR creation failed: {result.stderr}")
                return f"https://github.com/your-repo/pull/new/{branch_name}"

        except Exception as e:
            logger.error(f"PR creation failed: {e}")
            return ""


if __name__ == "__main__":
    # Test version manager
    manager = VersionManager()

    # Sample telemetry
    telemetry = {
        'uptime_percentage': 99.99,
        'p95_latency': 185,
        'error_rate': 0.4,
        'monthly_cost': 29.50,
        'forecast_accuracy': 0.91,
        'remediation_success_rate': 0.97,
        'compliance_score': 92
    }

    # Plan upgrade
    plan = manager.plan_upgrade(telemetry, target_improvements=['forecast_accuracy'])

    print(f"\n‚úì Plan generated: {plan.current_version} ‚Üí {plan.target_version}")
    print(f"  Changes: {len(plan.changes)}")
    print(f"  Risk: {plan.risk_level}")
