/**
 * Anomaly Predictor - LSTM + Isolation Forest Hybrid
 * Version: v2.6.0-2025-10-07
 *
 * Predicts anomalies 24 hours ahead using hybrid approach:
 * - LSTM for time-series forecasting
 * - Isolation Forest for anomaly detection
 * - Prophet for trend analysis (optional)
 *
 * @module aiops/AnomalyPredictor
 */

const logger = require('../config/logger').logger('anomaly-predictor');
const path = require('path');
const fs = require('fs').promises;

class AnomalyPredictor {
  constructor(config = {}) {
    this.config = {
      modelPath: config.modelPath || './aiops/models',
      minSamples: config.minSamples || 100,
      lstmLookback: config.lstmLookback || 24, // hours
      predictionHorizon: config.predictionHorizon || 24, // hours
      anomalyThreshold: config.anomalyThreshold || 0.85,
      ...config
    };

    this.models = {};
    this.trainingData = [];
    this.statistics = {};
    this.isInitialized = false;
  }

  /**
   * Initialize predictor and load models
   */
  async initialize() {
    logger.info('Initializing Anomaly Predictor');
    logger.info(`Model path: ${this.config.modelPath}`);

    try {
      // Create models directory if it doesn't exist
      await fs.mkdir(this.config.modelPath, { recursive: true });

      // Load pre-trained models (if available)
      await this._loadModels();

      // Initialize Isolation Forest parameters
      this._initializeIsolationForest();

      this.isInitialized = true;
      logger.info('Anomaly Predictor initialized');
    } catch (error) {
      logger.error('Failed to initialize Anomaly Predictor:', error);
      throw error;
    }
  }

  /**
   * Train models on historical data
   */
  async train(historicalData) {
    if (historicalData.length < this.config.minSamples) {
      logger.warn(`Insufficient training data: ${historicalData.length} < ${this.config.minSamples}`);
      return false;
    }

    logger.info(`Training on ${historicalData.length} samples...`);

    try {
      // Store training data
      this.trainingData = historicalData;

      // Group data by metric
      const metricGroups = this._groupByMetric(historicalData);

      // Train models for each metric
      for (const [metricName, samples] of Object.entries(metricGroups)) {
        logger.debug(`Training model for ${metricName} (${samples.length} samples)`);

        // Calculate statistics for baseline
        this.statistics[metricName] = this._calculateStatistics(samples);

        // Train LSTM model (simplified version using moving averages)
        this.models[metricName] = {
          type: 'lstm-simplified',
          weights: this._trainLSTMSimplified(samples),
          statistics: this.statistics[metricName],
          lastUpdated: new Date().toISOString()
        };
      }

      // Train Isolation Forest
      await this._trainIsolationForest(historicalData);

      // Save models
      await this._saveModels();

      logger.info(`Training complete for ${Object.keys(this.models).length} metrics`);
      return true;
    } catch (error) {
      logger.error('Training failed:', error);
      return false;
    }
  }

  /**
   * Predict anomalies for next N hours
   */
  async predict(currentMetrics, horizonHours = 24) {
    if (!this.isInitialized) {
      throw new Error('Predictor not initialized');
    }

    const predictions = [];

    try {
      // Extract metrics from current data
      const metrics = currentMetrics.metrics || {};

      for (const [metricName, metricData] of Object.entries(metrics)) {
        if (!metricData.value) continue;

        // LSTM forecast
        const forecast = this._forecastLSTM(metricName, metricData.value, horizonHours);

        // Isolation Forest anomaly detection
        const anomalyScore = this._detectAnomaly(metricName, forecast);

        // Calculate confidence
        const confidence = this._calculateConfidence(metricName, forecast, anomalyScore);

        // Root cause analysis
        const rootCause = this._analyzeRootCause(metricName, forecast, currentMetrics);

        predictions.push({
          metricName,
          currentValue: metricData.value,
          predictedValue: forecast.value,
          anomalyScore,
          confidence,
          timestamp: new Date(Date.now() + (horizonHours * 60 * 60 * 1000)).toISOString(),
          trend: forecast.trend,
          rootCause
        });
      }

      logger.debug(`Generated ${predictions.length} predictions`);
      return predictions;
    } catch (error) {
      logger.error('Prediction failed:', error);
      throw error;
    }
  }

  /**
   * Train simplified LSTM (moving averages + trend)
   * @private
   */
  _trainLSTMSimplified(samples) {
    const values = samples.map(s => s.value);

    // Calculate moving averages at different windows
    const ma7 = this._movingAverage(values, 7);
    const ma30 = this._movingAverage(values, 30);

    // Calculate trend
    const trend = this._calculateTrend(values);

    // Calculate seasonality (hourly, daily, weekly patterns)
    const seasonality = this._extractSeasonality(samples);

    return {
      movingAverages: { ma7, ma30 },
      trend,
      seasonality,
      sampleCount: samples.length
    };
  }

  /**
   * Forecast using LSTM model
   * @private
   */
  _forecastLSTM(metricName, currentValue, horizonHours) {
    const model = this.models[metricName];

    if (!model) {
      // No model, use simple extrapolation
      return {
        value: currentValue,
        trend: 'stable',
        confidence: 0.5
      };
    }

    const { weights, statistics } = model;
    const { trend, movingAverages, seasonality } = weights;

    // Forecast value using trend + seasonality
    const trendComponent = currentValue * (1 + (trend * horizonHours / 24));
    const seasonalComponent = this._getSeasonalAdjustment(seasonality, horizonHours);
    const predictedValue = trendComponent * seasonalComponent;

    // Determine trend direction
    let trendDirection = 'stable';
    if (predictedValue > currentValue * 1.1) trendDirection = 'increasing';
    if (predictedValue < currentValue * 0.9) trendDirection = 'decreasing';

    return {
      value: predictedValue,
      trend: trendDirection,
      confidence: this._calculateForecastConfidence(model, currentValue)
    };
  }

  /**
   * Initialize Isolation Forest
   * @private
   */
  _initializeIsolationForest() {
    this.isolationForest = {
      numTrees: 100,
      subsampleSize: 256,
      maxDepth: 10,
      trees: []
    };
  }

  /**
   * Train Isolation Forest
   * @private
   */
  async _trainIsolationForest(data) {
    // Simplified Isolation Forest implementation
    // In production, use a proper ML library like ml-isolation-forest

    const features = data.map(d => [d.value, this._extractHourOfDay(d.timestamp)]);

    this.isolationForest.trees = [];

    for (let i = 0; i < this.isolationForest.numTrees; i++) {
      const subsample = this._randomSubsample(features, this.isolationForest.subsampleSize);
      const tree = this._buildIsolationTree(subsample, 0);
      this.isolationForest.trees.push(tree);
    }

    logger.debug(`Trained Isolation Forest with ${this.isolationForest.numTrees} trees`);
  }

  /**
   * Detect anomaly using Isolation Forest
   * @private
   */
  _detectAnomaly(metricName, forecast) {
    if (!this.isolationForest.trees.length) {
      return this._simpleAnomalyDetection(metricName, forecast.value);
    }

    // Calculate average path length in forest
    const features = [forecast.value, new Date().getHours()];
    const avgPathLength = this._averagePathLength(features);

    // Normalize to [0, 1] anomaly score
    const c = this._c(this.isolationForest.subsampleSize);
    const anomalyScore = Math.pow(2, -avgPathLength / c);

    return anomalyScore;
  }

  /**
   * Simple anomaly detection (fallback)
   * @private
   */
  _simpleAnomalyDetection(metricName, predictedValue) {
    const stats = this.statistics[metricName];

    if (!stats) return 0;

    // Z-score based detection
    const zScore = Math.abs((predictedValue - stats.mean) / stats.stddev);

    // Convert z-score to anomaly score (0-1)
    return Math.min(zScore / 3, 1); // 3 sigma = 1.0 anomaly score
  }

  /**
   * Calculate prediction confidence
   * @private
   */
  _calculateConfidence(metricName, forecast, anomalyScore) {
    const model = this.models[metricName];

    if (!model) return 0.5;

    // Base confidence on model quality and data freshness
    const recency = Date.now() - new Date(model.lastUpdated).getTime();
    const recencyFactor = Math.max(0, 1 - (recency / (7 * 24 * 60 * 60 * 1000))); // Decay over 7 days

    const sampleFactor = Math.min(model.weights.sampleCount / this.config.minSamples, 1);

    // Combine factors
    const baseConfidence = (recencyFactor * 0.3) + (sampleFactor * 0.3) + (forecast.confidence * 0.4);

    // Reduce confidence for borderline anomalies
    if (anomalyScore < 0.7) {
      return baseConfidence * 0.7;
    }

    return Math.min(baseConfidence, 0.99);
  }

  /**
   * Analyze root cause
   * @private
   */
  _analyzeRootCause(metricName, forecast, currentMetrics) {
    const correlations = [];

    // Check correlations with other metrics
    const metrics = currentMetrics.metrics || {};

    for (const [otherMetric, data] of Object.entries(metrics)) {
      if (otherMetric === metricName || !data.value) continue;

      const correlation = this._calculateCorrelation(metricName, otherMetric);

      if (Math.abs(correlation) > 0.7) {
        correlations.push({
          metric: otherMetric,
          correlation,
          currentValue: data.value
        });
      }
    }

    if (correlations.length === 0) {
      return null;
    }

    // Sort by absolute correlation
    correlations.sort((a, b) => Math.abs(b.correlation) - Math.abs(a.correlation));

    return {
      primaryCause: correlations[0].metric,
      correlation: correlations[0].correlation,
      relatedMetrics: correlations.slice(1, 3).map(c => c.metric)
    };
  }

  /**
   * Helper: Group data by metric
   * @private
   */
  _groupByMetric(data) {
    const groups = {};

    for (const item of data) {
      if (!groups[item.metricName]) {
        groups[item.metricName] = [];
      }
      groups[item.metricName].push(item);
    }

    return groups;
  }

  /**
   * Helper: Calculate statistics
   * @private
   */
  _calculateStatistics(samples) {
    const values = samples.map(s => s.value).filter(v => v !== null);

    if (values.length === 0) {
      return { mean: 0, stddev: 0, min: 0, max: 0 };
    }

    const mean = values.reduce((a, b) => a + b, 0) / values.length;
    const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;
    const stddev = Math.sqrt(variance);

    return {
      mean,
      stddev,
      min: Math.min(...values),
      max: Math.max(...values),
      count: values.length
    };
  }

  /**
   * Helper: Moving average
   * @private
   */
  _movingAverage(values, window) {
    if (values.length < window) return values[values.length - 1] || 0;

    const sum = values.slice(-window).reduce((a, b) => a + b, 0);
    return sum / window;
  }

  /**
   * Helper: Calculate trend
   * @private
   */
  _calculateTrend(values) {
    if (values.length < 2) return 0;

    // Simple linear regression slope
    const n = values.length;
    const x = Array.from({ length: n }, (_, i) => i);
    const y = values;

    const sumX = x.reduce((a, b) => a + b, 0);
    const sumY = y.reduce((a, b) => a + b, 0);
    const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
    const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);

    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);

    return slope / sumY * n; // Normalized trend
  }

  /**
   * Helper: Extract seasonality
   * @private
   */
  _extractSeasonality(samples) {
    const hourlyPattern = new Array(24).fill(0);
    const hourlyCounts = new Array(24).fill(0);

    for (const sample of samples) {
      const hour = new Date(sample.timestamp).getHours();
      hourlyPattern[hour] += sample.value;
      hourlyCounts[hour]++;
    }

    // Average by hour
    for (let i = 0; i < 24; i++) {
      if (hourlyCounts[i] > 0) {
        hourlyPattern[i] /= hourlyCounts[i];
      }
    }

    return { hourly: hourlyPattern };
  }

  /**
   * Helper: Get seasonal adjustment
   * @private
   */
  _getSeasonalAdjustment(seasonality, hoursAhead) {
    const targetHour = (new Date().getHours() + hoursAhead) % 24;
    const avgValue = seasonality.hourly.reduce((a, b) => a + b, 0) / 24;
    return seasonality.hourly[targetHour] / avgValue;
  }

  /**
   * Helper: Calculate forecast confidence
   * @private
   */
  _calculateForecastConfidence(model, currentValue) {
    const { statistics } = model;

    // Confidence based on deviation from mean
    const deviation = Math.abs(currentValue - statistics.mean) / statistics.stddev;

    return Math.max(0, 1 - (deviation / 3));
  }

  /**
   * Helper: Extract hour of day
   * @private
   */
  _extractHourOfDay(timestamp) {
    return new Date(timestamp).getHours();
  }

  /**
   * Helper: Random subsample
   * @private
   */
  _randomSubsample(array, size) {
    const shuffled = array.slice();
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled.slice(0, Math.min(size, array.length));
  }

  /**
   * Helper: Build isolation tree
   * @private
   */
  _buildIsolationTree(data, depth) {
    if (depth >= this.isolationForest.maxDepth || data.length <= 1) {
      return { type: 'leaf', size: data.length };
    }

    // Random feature and split point
    const featureIdx = Math.floor(Math.random() * data[0].length);
    const values = data.map(d => d[featureIdx]);
    const min = Math.min(...values);
    const max = Math.max(...values);
    const splitValue = min + Math.random() * (max - min);

    const left = data.filter(d => d[featureIdx] < splitValue);
    const right = data.filter(d => d[featureIdx] >= splitValue);

    return {
      type: 'node',
      featureIdx,
      splitValue,
      left: this._buildIsolationTree(left, depth + 1),
      right: this._buildIsolationTree(right, depth + 1)
    };
  }

  /**
   * Helper: Average path length in forest
   * @private
   */
  _averagePathLength(features) {
    const pathLengths = this.isolationForest.trees.map(tree =>
      this._pathLength(tree, features, 0)
    );

    return pathLengths.reduce((a, b) => a + b, 0) / pathLengths.length;
  }

  /**
   * Helper: Path length in tree
   * @private
   */
  _pathLength(node, features, depth) {
    if (node.type === 'leaf') {
      return depth + this._c(node.size);
    }

    if (features[node.featureIdx] < node.splitValue) {
      return this._pathLength(node.left, features, depth + 1);
    } else {
      return this._pathLength(node.right, features, depth + 1);
    }
  }

  /**
   * Helper: Average path length normalization constant
   * @private
   */
  _c(n) {
    if (n <= 1) return 0;
    return 2 * (Math.log(n - 1) + 0.5772156649) - (2 * (n - 1) / n);
  }

  /**
   * Helper: Calculate correlation
   * @private
   */
  _calculateCorrelation(metric1, metric2) {
    // Simplified correlation (would need historical data in production)
    // For now, return predefined correlations

    const knownCorrelations = {
      'api_latency_p95_ms:db_connection_pool_active': 0.8,
      'cache_hit_rate_percent:api_latency_p95_ms': -0.7,
      'memory_usage_percent:cpu_usage_percent': 0.6,
      'error_rate_percent:api_latency_p95_ms': 0.75
    };

    const key = `${metric1}:${metric2}`;
    const reverseKey = `${metric2}:${metric1}`;

    return knownCorrelations[key] || knownCorrelations[reverseKey] || 0;
  }

  /**
   * Load models from disk
   * @private
   */
  async _loadModels() {
    try {
      const modelFile = path.join(this.config.modelPath, 'models.json');
      const data = await fs.readFile(modelFile, 'utf8');
      const saved = JSON.parse(data);

      this.models = saved.models || {};
      this.statistics = saved.statistics || {};

      logger.info(`Loaded ${Object.keys(this.models).length} models from disk`);
    } catch (error) {
      logger.debug('No saved models found, starting fresh');
    }
  }

  /**
   * Save models to disk
   * @private
   */
  async _saveModels() {
    try {
      const modelFile = path.join(this.config.modelPath, 'models.json');
      const data = {
        models: this.models,
        statistics: this.statistics,
        savedAt: new Date().toISOString()
      };

      await fs.writeFile(modelFile, JSON.stringify(data, null, 2));
      logger.debug('Models saved to disk');
    } catch (error) {
      logger.error('Failed to save models:', error);
    }
  }
}

module.exports = AnomalyPredictor;
